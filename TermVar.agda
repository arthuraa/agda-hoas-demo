module TermVar where

import Relation.Binary.PropositionalEquality as Eq
open Eq using (_≡_; refl; cong; sym)
open Eq.≡-Reasoning
open import Data.Nat
open import Data.Fin hiding (_+_)
open import Data.Product

infix 6 ƛ_
infix 6 `_
infixl 7 _·_

data Term (n : ℕ) : Set where

  `_ : Fin n → Term n

  ƛ_ : Term (suc n) → Term n

  _·_ : Term n → Term n → Term n

-- This is the standard elimination principle that would be generated by Coq

Term-elim-gen : (A : ∀ n → Term n → Set) →
                (∀ {n} x → A n (` x)) →
                (∀ {n} t → A (suc n) t → A n (ƛ t)) →
                (∀ {n} t₁ t₂ → A n t₁ → A n t₂ → A n (t₁ · t₂)) →
                ∀ {n} t → A n t
Term-elim-gen A H` Hƛ H· t = go t
  where go : ∀ {n} → (t : Term n) → A n t
        go (` x) = H` x
        go (ƛ t) = Hƛ t (go t)
        go (t₁ · t₂) = H· t₁ t₂ (go t₁) (go t₂)

-- This elimination principle is similar to the above, except that we are
-- allowed to place a lower bound on the number of free variables that the
-- eliminated term has.

Term-elim-gen-2 : ∀ {n} (A : ∀ m → Term (m + n) → Set) →
                  (∀ {m} x → A m (` x)) →
                  (∀ {m} t → A (suc m) t → A m (ƛ t)) →
                  (∀ {m} t₁ t₂ → A m t₁ → A m t₂ → A m (t₁ · t₂)) →
                  ∀ {m} t → A m t
Term-elim-gen-2 {n} A H` Hƛ H· {m} t = go t
  where go : ∀ {m} t → A m t
        go {m} (` x) = H` x
        go {m} (ƛ t) = Hƛ t (go t)
        go {m} (t₁ · t₂) = H· t₁ t₂ (go t₁) (go t₂)

ext : ∀ {n m} → (Fin n → Fin m) → Fin (suc n) → Fin (suc m)
ext ρ zero = zero
ext ρ (suc x) = suc (ρ x)

rename : ∀ {n} {m} → (Fin n → Fin m) → Term n → Term m
rename ρ (` x) = ` ρ x
rename {n} {m} ρ (ƛ t) = ƛ rename (ext ρ) t
rename ρ (t₁ · t₂) = (rename ρ t₁) · (rename ρ t₂)

exts : ∀ {n m} → (Fin n → Term m) → Fin (suc n) → Term (suc m)
exts σ zero = ` zero
exts σ (suc x) = rename suc (σ x)

subst : ∀ {n} {m} → (Fin n → Term m) → Term n → Term m
subst σ (` x) = σ x
subst {n} {m} σ (ƛ t) = ƛ subst (exts σ) t
subst σ (t₁ · t₂) = (subst σ t₁) · (subst σ t₂)

subst-zero : ∀ {n} → Term n → Fin (suc n) → Term n
subst-zero t zero = t
subst-zero _ (suc x) = ` x

_[_] : ∀ {n} → Term (suc n) → Term n → Term n
_[_] {n} t₁ t₂ = subst (subst-zero t₂) t₁

infix 2 _—→_

data _—→_ : ∀ {n} → Term n → Term n → Set where

  ξ₁ : ∀ {n} {t₁ t₁' t₂ : Term n} →
       t₁ —→ t₁' →
       t₁ · t₂ —→ t₁' · t₂

  ξ₂ : ∀ {n} {t₁ t₂ t₂' : Term n} →
       t₂ —→ t₂' →
       t₁ · t₂ —→ t₁ · t₂'

  β : ∀ {n} {t₁ : Term (suc n)} {t₂ : Term n} →
      (ƛ t₁) · t₂ —→ t₁ [ t₂ ]

  ζ : ∀ {n} {t t' : Term (suc n)} →
      t —→ t' →
      ƛ t —→ ƛ t'

infix 2 _⇒_

data _⇒_ : ∀ {n} → Term n → Term n → Set where

  pvar : ∀ {n} {x : Fin n} →
         ` x ⇒ ` x

  pabs : ∀ {n} {t t' : Term (suc n)} →
         t ⇒ t' →
         ƛ t ⇒ ƛ t'

  papp : ∀ {n} {t₁ t₁' t₂ t₂' : Term n} →
         t₁ ⇒ t₁' →
         t₂ ⇒ t₂' →
         t₁ · t₂ ⇒ t₁' · t₂'

  pbeta : ∀ {n} {t₁ t₁' : Term (suc n)} {t₂ t₂' : Term n} →
          t₁ ⇒ t₁' →
          t₂ ⇒ t₂' →
          (ƛ t₁) · t₂ ⇒ t₁' [ t₂' ]

par-refl : ∀ {n} {t : Term n} → t ⇒ t
par-refl {n} {` x} = pvar
par-refl {n} {ƛ t} = pabs par-refl
par-refl {n} {t₁ · t₂} = papp par-refl par-refl

exts-≡ : ∀ {n m} {σ₁ σ₂ : Fin n → Term m} →
  (∀ x → σ₁ x ≡ σ₂ x) →
  (∀ x → exts σ₁ x ≡ exts σ₂ x)
exts-≡ σ₁≡σ₂ zero = refl
exts-≡ σ₁≡σ₂ (suc x) rewrite σ₁≡σ₂ x = refl

subst-≡ : ∀ {n m} {σ₁ σ₂ : Fin n → Term m} →
  (∀ x → σ₁ x ≡ σ₂ x) →
  ∀ t → subst σ₁ t ≡ subst σ₂ t
subst-≡ σ₁≡σ₂ (` x) = σ₁≡σ₂ x
subst-≡ σ₁≡σ₂ (ƛ t) 
  rewrite subst-≡ (exts-≡ σ₁≡σ₂) t = refl
subst-≡ σ₁≡σ₂ (t₁ · t₂)
  rewrite subst-≡ σ₁≡σ₂ t₁ | subst-≡ σ₁≡σ₂ t₂ = refl

ext-≡ : ∀ {n m} {ρ₁ ρ₂ : Fin n → Fin m} →
  (∀ x → ρ₁ x ≡ ρ₂ x) →
  (∀ x → ext ρ₁ x ≡ ext ρ₂ x)
ext-≡ ρ₁≡ρ₂ zero = refl
ext-≡ ρ₁≡ρ₂ (suc x) rewrite ρ₁≡ρ₂ x = refl

rename-≡ : ∀ {n m} {σ₁ σ₂ : Fin n → Fin m} →
  (∀ x → σ₁ x ≡ σ₂ x) →
  (∀ t → rename σ₁ t ≡ rename σ₂ t)
rename-≡ σ₁≡σ₂ (` x) rewrite σ₁≡σ₂ x = refl
rename-≡ σ₁≡σ₂ (ƛ t) rewrite rename-≡ (ext-≡ σ₁≡σ₂) t = refl
rename-≡ σ₁≡σ₂ (t₁ · t₂)
  rewrite rename-≡ σ₁≡σ₂ t₁ | rename-≡ σ₁≡σ₂ t₂ = refl

ext-∘ : ∀ {n m p} (ρ₁ : Fin n → Fin m) (ρ₂ : Fin p → Fin n) →
  ∀ x → ext ρ₁ (ext ρ₂ x) ≡ ext (λ x → ρ₁ (ρ₂ x)) x
ext-∘ ρ₁ ρ₂ zero = refl
ext-∘ ρ₁ ρ₂ (suc x) = refl

rename-rename : ∀ {n m p} (ρ₁ : Fin n → Fin m) (ρ₂ : Fin p → Fin n) →
  ∀ t → rename ρ₁ (rename ρ₂ t) ≡ rename (λ x → ρ₁ (ρ₂ x)) t
rename-rename ρ₁ ρ₂ (` x) = refl
rename-rename ρ₁ ρ₂ (ƛ t)
  rewrite rename-rename (ext ρ₁) (ext ρ₂) t
  | rename-≡ (ext-∘ ρ₁ ρ₂) t = refl
rename-rename ρ₁ ρ₂ (t₁ · t₂)
  rewrite rename-rename ρ₁ ρ₂ t₁
  | rename-rename ρ₁ ρ₂ t₂ = refl

rename-ext-exts : ∀ {n m p} (ρ : Fin n → Fin m) (σ : Fin p → Term n) →
  ∀ x → rename (ext ρ) (exts σ x) ≡ exts (λ x → rename ρ (σ x)) x
rename-ext-exts ρ σ zero = refl
rename-ext-exts ρ σ (suc x)
  rewrite rename-rename (ext ρ) suc (σ x)
  | rename-rename suc ρ (σ x) = refl

rename-subst : ∀ {n m p} (ρ : Fin n → Fin m) (σ : Fin p → Term n) (t : Term p) →
  rename ρ (subst σ t) ≡ subst (λ x → rename ρ (σ x)) t

rename-subst ρ σ (` x) = refl

rename-subst ρ σ (ƛ t)
  rewrite rename-subst (ext ρ) (exts σ) t
  | subst-≡ (rename-ext-exts ρ σ) t = refl

rename-subst ρ σ (t₁ · t₂)
  rewrite rename-subst ρ σ t₁ | rename-subst ρ σ t₂ = refl


exts-ext : ∀ {n m p} (σ : Fin n → Term m) (ρ : Fin p → Fin n) →
  ∀ x → exts σ (ext ρ x) ≡ exts (λ x → σ (ρ x)) x

exts-ext σ ρ zero = refl
exts-ext σ ρ (suc x) = refl

subst-rename : ∀ {n m p} (σ : Fin n → Term m) (ρ : Fin p → Fin n) (t : Term p) →
  subst σ (rename ρ t) ≡ subst (λ x → σ (ρ x)) t

subst-rename σ ρ (` x) = refl
subst-rename σ ρ (ƛ t)
  rewrite subst-rename (exts σ) (ext ρ) t
  | subst-≡ (exts-ext σ ρ) t = refl
subst-rename σ ρ (t₁ · t₂)
  rewrite subst-rename σ ρ t₁ | subst-rename σ ρ t₂ = refl

rename-[] : ∀ {n m} (ρ : Fin n → Fin m) (t₁ : Term (suc n)) (t₂ : Term n) →
  rename ρ (t₁ [ t₂ ]) ≡ (rename (ext ρ) t₁) [ rename ρ t₂ ]

rename-[] {n} {m} ρ t₁ t₂ =
  begin
    rename ρ (t₁ [ t₂ ])
  ≡⟨⟩
    rename ρ (subst (subst-zero t₂) t₁)
  ≡⟨ rename-subst ρ (subst-zero t₂) t₁ ⟩
    subst (λ x → rename ρ (subst-zero t₂ x)) t₁
  ≡⟨ subst-≡ lem t₁ ⟩
    subst (λ x → subst-zero (rename ρ t₂) (ext ρ x)) t₁
  ≡⟨ sym (subst-rename (subst-zero (rename ρ t₂)) (ext ρ) t₁) ⟩
    subst (subst-zero (rename ρ t₂)) (rename (ext ρ) t₁)
  ≡⟨⟩
    (rename (ext ρ) t₁) [ rename ρ t₂ ]
  ∎
  where lem : ∀ x → rename ρ (subst-zero t₂ x) ≡ subst-zero (rename ρ t₂) (ext ρ x)
        lem zero = refl
        lem (suc x) = refl

par-rename : ∀ {n m} {ρ : Fin n → Fin m} {t t' : Term n} →
  t ⇒ t' →
  rename ρ t ⇒ rename ρ t'

par-rename pvar = pvar

par-rename (pabs t⇒t') = pabs (par-rename t⇒t')

par-rename (papp t₁⇒t₁' t₂⇒t₂') = papp (par-rename t₁⇒t₁') (par-rename t₂⇒t₂')

par-rename {n} {m} {ρ} (pbeta {_} {t₁} {t₁'} {t₂} {t₂'} t₁⇒t₁' t₂⇒t₂')
    with pbeta (par-rename {_} {_} {ext ρ} t₁⇒t₁')
               (par-rename {_} {_} {ρ} t₂⇒t₂')
... | G rewrite (rename-[] ρ t₁' t₂') = G

par-subst : ∀ {n m} (σ σ' : Fin n → Term m) → Set
par-subst σ σ' =  ∀ x → σ x ⇒ σ' x

par-subst-exts : ∀ {n m} {σ σ' : Fin n → Term m} →
                 par-subst σ σ' →
                 par-subst (exts σ) (exts σ')
par-subst-exts σ⇒σ' zero = pvar
par-subst-exts σ⇒σ' (suc x) = par-rename (σ⇒σ' x)

subst-subst : ∀ {n m p} (σ₁ : Fin n → Term m) (σ₂ : Fin p → Term n) t →
              subst σ₁ (subst σ₂ t)
              ≡ subst (λ x → subst σ₁ (σ₂ x)) t

subst-subst σ₁ σ₂ (` x) = refl
subst-subst σ₁ σ₂ (ƛ t)
  rewrite subst-subst (exts σ₁) (exts σ₂) t = cong ƛ_ (subst-≡ lem t)
  where
  lem : ∀ x → subst (exts σ₁) (exts σ₂ x) ≡ exts (λ x → subst σ₁ (σ₂ x)) x
  lem zero = refl
  lem (suc x)
    rewrite subst-rename (exts σ₁) suc (σ₂ x)
    | rename-subst suc σ₁ (σ₂ x) = refl
subst-subst σ₁ σ₂ (t₁ · t₂)
  rewrite subst-subst σ₁ σ₂ t₁
  | subst-subst σ₁ σ₂ t₂ = refl

subst-` : ∀ {n} (t : Term n) → subst `_ t ≡ t
subst-` (` x) = refl
subst-` (ƛ t) =
  begin
    subst `_ (ƛ t)
  ≡⟨⟩
    ƛ (subst (exts `_) t)
  ≡⟨ cong ƛ_ (subst-≡ lem t) ⟩
    ƛ subst `_ t
  ≡⟨ cong ƛ_ (subst-` t) ⟩
    ƛ t
  ∎
  where
  lem : ∀ x → exts `_ x ≡ ` x
  lem zero = refl
  lem (suc x) = refl
subst-` (t₁ · t₂)
  rewrite subst-` t₁ | subst-` t₂ = refl

subst-[] : ∀ {n m} (σ : Fin n → Term m) t₁ t₂ →
  subst (exts σ) t₁ [ subst σ t₂ ] ≡ subst σ (t₁ [ t₂ ])

subst-[] σ t₁ t₂ =
  begin
    subst (exts σ) t₁ [ subst σ t₂ ]
  ≡⟨⟩
    subst (subst-zero (subst σ t₂)) (subst (exts σ) t₁)
  ≡⟨ subst-subst (subst-zero (subst σ t₂)) (exts σ) t₁ ⟩
   subst (λ x → subst (subst-zero (subst σ t₂)) (exts σ x)) t₁
  ≡⟨ subst-≡ lem t₁ ⟩
   subst (λ x → subst σ (subst-zero t₂ x)) t₁
  ≡˘⟨ subst-subst σ (subst-zero t₂) t₁ ⟩
    subst σ (subst (subst-zero t₂) t₁)
  ≡⟨⟩
    subst σ (t₁ [ t₂ ])
  ∎
  where lem : ∀ x → subst (subst-zero (subst σ t₂)) (exts σ x)
                    ≡ subst σ (subst-zero t₂ x)
        lem zero = refl
        lem (suc x)
          rewrite subst-rename (subst-zero (subst σ t₂)) suc (σ x)
          = subst-` (σ x)

subst-par : ∀ {n m} {σ σ' : Fin n → Term m} {t t' : Term n} →
            par-subst σ σ' →
            t ⇒ t' →
            subst σ t ⇒ subst σ' t'
subst-par σ⇒σ' (pvar {x = x}) =
  σ⇒σ' x
subst-par σ⇒σ' (pabs t⇒t') =
  pabs (subst-par (par-subst-exts σ⇒σ') t⇒t')
subst-par σ⇒σ' (papp t₁⇒t₁' t₂⇒t₂') =
  papp (subst-par σ⇒σ' t₁⇒t₁') (subst-par σ⇒σ' t₂⇒t₂')
subst-par {σ' = σ'} σ⇒σ' (pbeta {_} {t₁} {t₂} {t₁'} {t₂'} t₁⇒t₁' t₂⇒t₂')
  with pbeta (subst-par (par-subst-exts σ⇒σ') t₁⇒t₁') (subst-par σ⇒σ' t₂⇒t₂')
... | G rewrite subst-[] σ' t₂ t₂' = G

par-subst-zero : ∀ {n} {t t' : Term n} →
                 t ⇒ t' →
                 par-subst (subst-zero t) (subst-zero t')
par-subst-zero t⇒t' zero = t⇒t'
par-subst-zero t⇒t' (suc x) = pvar

par-[] : ∀ {n} {t₁ t₁' : Term (suc n)} {t₂ t₂' : Term n} →
         t₁ ⇒ t₁' →
         t₂ ⇒ t₂' →
         t₁ [ t₂ ] ⇒ t₁' [ t₂' ]
par-[] t₁⇒t₁' t₂⇒t₂' = subst-par (par-subst-zero t₂⇒t₂') t₁⇒t₁'

_⁺ : ∀ {n} → Term n → Term n

(` x) ⁺ = ` x

(ƛ t) ⁺ = ƛ (t ⁺)

((ƛ t₁) · t₂) ⁺ = (t₁ ⁺) [ t₂ ⁺ ]

(t₁ · t₂) ⁺ = (t₁ ⁺) · (t₂ ⁺)

par-triangle : ∀ {n} {t t' : Term n} →
               t ⇒ t' →
               t' ⇒ t ⁺

par-triangle pvar = pvar
par-triangle (pabs t⇒t') = pabs (par-triangle t⇒t')
par-triangle (pbeta t₁⇒t₁' t₂⇒t₂') = par-[] (par-triangle t₁⇒t₁') (par-triangle t₂⇒t₂')
par-triangle (papp {t₁ = ƛ t₁} {t₁' = ƛ t₁'} (pabs t₁⇒t₁') t₂⇒t₂') =
  pbeta (par-triangle t₁⇒t₁') (par-triangle t₂⇒t₂')
par-triangle (papp {t₁ = _ · _} t₁⇒t₁' t₂⇒t₂') = papp (par-triangle t₁⇒t₁') (par-triangle t₂⇒t₂')
par-triangle (papp {t₁ = ` _} t₁⇒t₁' t₂⇒t₂') = papp (par-triangle t₁⇒t₁') (par-triangle t₂⇒t₂')

par-diamond : ∀ {n} (t t₁' t₂' : Term n) →
              t ⇒ t₁' →
              t ⇒ t₂' →
              Σ[ t'' ∈ Term n ] (t₁' ⇒ t'') × (t₂' ⇒ t'')
par-diamond _ _ _ t⇒t₁' t⇒t₂' = _ , par-triangle t⇒t₁' , par-triangle t⇒t₂'
